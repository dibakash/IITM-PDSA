# Analysis of Algorithms

<!-- Notes maintained by: Dibakash Baruah -->

## What are we interested in when we are computing the performance of an Algorithm?

---

### Two main resources of Interest:

- Running time - how much time the Algorithm takes
- Space - memory requirements

### Time depends of Processing Power -

- Impossible to change for a given hardware
- Based on the present computing power of the CPUs ( last 10 / 15 years (this is 2022) ), Python can do around 10<sup>7</sup> operations/ second.
- Enhancing hardware has only a limited impact at a practical level
- Meaning, even if we upgrade to a machine which is 10 times faster would not have any significant impact on something which is inherently long to compute.

### Storage is limited by Available Memory

- Easier to configure, augment

Because of this reason, when we talk about performance the focus is more on time rather than space aspect of performance

<br>

### Input Size

---

- Running time depends on input size. For example, a larger array takes more time to sort than a smaller array. We can think of time efficiency as a function of input size <em>n</em> as running time <em>t(n)</em>
- Of course, different inputs of same input size <em>n</em> may take different amounts of time. For example, two arrays of same size may take different amount of time to sort if one of them is already sorted and the other one is not.

---

## Why running time is important? (from week 1 example)

---

Let's have a look at the following problem (sim card mapped to Aadhar card)

- Suppose there is need to verify Aadhar number associated with a mobile number so that a person can be verified.
- Assuming everyone have an Aadhar card in India (population of 100 Cr), there are around 10<sup>9</sup> Aadhar cards. Similarly, assuming person having phones have multiple sim cards, there are around 10<sup>9</sup> sim cards as well
- So, if we do a nested loop to check whether the Aadhar card provided is valid or not against the sim card provided we'll have to do 10<sup>9</sup> &times; 10<sup>9</sup> &equals; 10<sup>18</sup>
- with python, it will take:

  > = 10<sup>18</sup> &divide; 10<sup>7</sup> = 10<sup>11</sup> Seconds!
  > <br> &rArr; 10<sup>11</sup> &divide; 60 &asymp; 1.67&times;10<sup>9</sup> mins
  > <br> &rArr; 1.67&times;10<sup>9</sup> &divide; 60 &asymp; 2.78&times;10<sup>7</sup> hours
  > <br> &rArr; 2.78&times;10<sup>7</sup> &divide; 24 &asymp; 1158333 days
  > <br> &asymp; 3200 Years! (Lol)

So, we'll need 3200 years to verify whether correct Aadhar details is mapped to the sim card or not!

### What can be done so that the problem is manageable?

A common strategy is to use the divide and conquer approach (logarithmic) by dividing the problem statement in half in every step until a solution is obtained

- let's say we need to verify the Aadhar card associated with a given sim card.
- The best way is to do a binary search (divide and conquer) by halving the Aadhar data in each go (assuming the Aadhar numbers are in sorted order, which is a prerequisite for this to work).
- When we divide a data in half 10 times we reduce its size roughly by 1000 times (as 2<sup>10</sup> = 1024 ).
  > after halving 10 times, 10<sup>9</sup> becomes 10<sup>6</sup><br>
  > after halving 10 more times, 10<sup>6</sup> becomes 10<sup>3</sup><br>
  > after halving 10 more times, 10<sup>3</sup> becomes 1

&there4; we'll need 10<sup>9</sup>&times;30 computations with this approach which in terms of python will need ( 10<sup>9</sup>&times;30 )&divide;10<sup>7</sup> = 3000 seconds = 50 mins. This is a huge improvement (obviously as compared to 3200 years) and is just a work of around 1 hour to carry out the needed verification amongst a population of 1 billion.

- This is why running time of an algorithm matters.

> - The halving of the operations in terms of mathematics can be thought of as <code>Log<sub>2</sub>n = k &rArr; 2<sup>k</sup>= n</code>. The <code>Log<sub>2</sub>n</code> is nothing but number of time we need to divide <code>n</code> by <code>2</code> to reach 1 or number of times we need to multiply <code>2</code> to reach <code>n</code>.<br>
> - In terms of programming while representing time complexities, in general we write <code>Log<sub>2</sub>n</code> as <code>Logn</code> (omitting the base 2).<br>
> - Specifically, we reduced the the running time of the above operation from <code>n<sup>2</sup></code> (naive algorithm) to <code>nLogn</code> and we can already see how <code>nLogn</code> is way better than <code>n<sup>2</sup></code>.

---

## Example 2: Video Game

---

- [ ] pending
